For grok-skd:
	Maybe add
		on_client_side_tool_calls(&ctx, &calls)
		on_server_side_tool_calls(&ctx, &calls)

For grok-cli:
	Build a tool execution engine that is built on a HashMap<String, Job> as primary data struct and a Vec<String> as the execution queue.
	I'm thinking of building the engine like a "service" that other services send jobs to via a channel.
	Jobs get executed and results get sent back to origin.
	Tool engine knows what it can do and has predfined Job types.
	In the context of chat streaming, once a job is received from the AI, create a job from predined types, send the job for execution then wait and poll till it's complete.

	Rough tech details:

		trait Job {
			type Inputs

			fn get_inputs()
		}

		fn send_job(mailbox, job)
		async fn send_and_poll_job(mailbox, job)
