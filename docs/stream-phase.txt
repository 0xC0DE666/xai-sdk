================================================================================
Stream phase tracking: analysis and implementation plan
================================================================================

1. ANALYSIS OF debug/chunks.txt — HOW CHUNKS ARE STREAMED
---------------------------------------------------------

1.1 Top-level structure

  - The stream is a sequence of GetChatCompletionChunk values.
  - Each chunk has:
    - id, created, model, system_fingerprint, usage, citations, debug_output
    - outputs: [CompletionOutputChunk]  — typically ONE output per chunk in the trace

1.2 Per-chunk output (CompletionOutputChunk)

  - index: i32
    - Identifies which "output" this chunk belongs to. In the trace: 0, 1, 2, 3.
    - Outputs are ordered: all index 0 chunks, then index 1, then 2, then 3, etc.
  - delta: Option<Delta>
    - Present for every chunk that carries new content; can be Some(Delta { content: "", ... }) for tool/control chunks.
  - finish_reason: FinishReason
    - ReasonInvalid (0): streaming in progress, more data may follow for this output.
    - ReasonToolCalls (4): this output ended with tool calls (e.g. index 0 in the trace).
    - ReasonStop (3): this output ended normally (e.g. final content output, index 3).
  - logprobs: optional

1.3 Delta contents

  - content: str           — user-visible text (can be "" for reasoning/tool-only chunks).
  - reasoning_content: str — chain-of-thought / reasoning tokens (can be "" when no reasoning in this delta).
  - role: MessageRole      — RoleAssistant, RoleTool, etc.
  - tool_calls: [ToolCall] — server-side or client-side tool call deltas.
  - encrypted_content, citations

  Token semantics (for phase tracking):
  - A delta with non-empty reasoning_content contributes one (or more) reasoning tokens.
  - A delta with non-empty content contributes one (or more) content tokens.
  - The SDK currently counts one token per delta when the corresponding string is non-empty (see OutputStats::inc).

1.4 Observed stream shape (from debug/chunks.txt)

  - Index 0: Several chunks with tool_calls (XSearchTool, InProgress), then one chunk with finish_reason: ReasonToolCalls, empty tool_calls.
  - Index 1: One chunk, role RoleTool, tool_calls with status Completed (no content/reasoning).
  - Index 2: One chunk, same pattern (tool result).
  - Index 3: Many chunks; each has content like "###", " Last", " Two", " Tweets", ... and reasoning_content: "".
  - Last chunk for index 3: delta with content: "", reasoning_content: "", finish_reason: ReasonStop.
    - This is the "output finished" signal; usage and citations appear on this chunk.

  So:
  - One output per chunk in this trace; output index increases over time (0 → 1 → 2 → 3).
  - Reasoning phase: no reasoning tokens in this trace for index 3 (all reasoning_content empty).
  - Content phase: content tokens stream until the final chunk with ReasonStop and empty delta.

1.5 Chunk metadata

  - Chunks with created: Some(...) carry usage (completion_tokens, reasoning_tokens, etc.); "tool result" chunks (index 1, 2) have created: None and zero usage.
  - finish_reason is per output and is the authoritative "this output is done" signal when not ReasonInvalid.

================================================================================
2. FROM STREAM CHUNKS TO WHAT NEEDS TO BE IMPLEMENTED
-----------------------------------------------------

2.1 Current behavior (delta-based phase status)

  - For each chunk, for each output in chunk.outputs, the code:
    1. Updates OutputStats: total_reasoning_tokens, total_content_tokens, finish_reason (via merge).
    2. Computes reasoning_status and content_status using get_reasoning_status and get_content_status from the *current delta* and output.finish_reason.
    3. Uses these statuses to build OutputContext and to fire on_reasoning_complete / on_content_complete once (guarded by reasoning_complete_flags / content_complete_flags).

  - get_reasoning_status(reasoning_content, content, finish_reason):
    - has_reasoning = !reasoning_content.is_empty()
    - has_content  = !content.is_empty()
    - is_finished  = (finish_reason != ReasonInvalid)
    - Complete if !has_reasoning && (has_content || is_finished)
    - Pending if has_reasoning && !has_content
    - Init otherwise

  - get_content_status(reasoning_content, content, finish_reason):
    - Same has_* and is_finished
    - Complete if !has_reasoning && is_finished
    - Pending if has_content
    - Init otherwise

  So: phase status is derived from the *current* delta and the *current* finish_reason. It can change every chunk and is not yet driven by accumulated stats.

2.2 Intended behavior (stats-based phase status)

  - We already accumulate per-output:
    - total_reasoning_tokens, total_content_tokens (via OutputStats::inc and merge),
    - finish_reason (last one seen for that output, via merge).
  - Goal: compute the same logical PhaseStatus (Init / Pending / Complete) for reasoning and content from these accumulated stats instead of from the current delta.
  - Benefits:
    - Single source of truth (stats) for progress.
    - Status is stable and consistent with the full history of the output (no per-delta flicker).
    - Enables future extensions (e.g. progress percentages from token counts) without duplicating logic.

2.3 What must be implemented

  - Implement get_output_status(cur_output_stats, prev_output_stats) -> (PhaseStatus, PhaseStatus).
  - Replace the use of get_reasoning_status and get_content_status in the process loop with get_output_status.
  - Remove get_reasoning_status and get_content_status (or keep only for tests if needed).
  - Preserve semantics so that on_reasoning_complete and on_content_complete still fire exactly once per output when the phase transitions to Complete, as they do today.

================================================================================
3. IMPLEMENTATION PLAN
-----------------------------------------------------

3.1 Semantics of get_output_status (stats-based)

  Inputs:
  - cur_output_stats: &OutputStats
      - index, total_reasoning_tokens, total_content_tokens, finish_reason
  - prev_output_stats: Option<&OutputStats>
      - Reserved for future use (e.g. enforce "content only after reasoning" across outputs). Current delta-based logic does not use previous output; for parity we can ignore it.

  Reasoning status (same logic as get_reasoning_status, expressed in stats):
  - is_finished = (cur_output_stats.finish_reason != FinishReason::ReasonInvalid)
  - Reasoning Complete when: we have passed the reasoning phase
    - No reasoning tokens and (we have content tokens or the output is finished):
      total_reasoning_tokens == 0 && (total_content_tokens > 0 || is_finished)
  - Reasoning Pending when: we are in the reasoning phase
    - total_reasoning_tokens > 0 && total_content_tokens == 0
  - Otherwise: Init

  Content status (same logic as get_content_status, expressed in stats):
  - Content Complete when: output is finished
    - is_finished
  - Content Pending when: we have content tokens
    - total_content_tokens > 0 && !is_finished
  - Otherwise: Init

  Edge cases:
  - Output that only has tool calls (no reasoning, no content): total_* both 0, finish_reason e.g. ReasonToolCalls → reasoning Complete (no reasoning and finished), content Complete (finished).
  - Output that has reasoning then content: reasoning goes Init → Pending → Complete when content starts or finish; content goes Init → Pending → Complete on finish.
  - prev_output_stats: leave unused for now; signature already exists for future use.

3.2 Code changes

  A. Implement get_output_status in sdk/src/chat.rs
     - Add helper or inline: is_finished = cur_output_stats.finish_reason != FinishReason::ReasonInvalid.into()
     - Reasoning: if total_reasoning_tokens == 0 && (total_content_tokens > 0 || is_finished) { Complete } else if total_reasoning_tokens > 0 && total_content_tokens == 0 { Pending } else { Init }
     - Content: if is_finished { Complete } else if total_content_tokens > 0 { Pending } else { Init }
     - Return (reasoning_status, content_status).

  B. Switch the process loop to stats-based status
     - After cur_output_stats.inc(...) and the entry().and_modify().or_insert(cur_output_stats), we have updated output_stats for cur_output_index.
     - Get the merged stats: e.g. let stats = output_stats.get(&cur_output_index).unwrap_or(&cur_output_stats) (or use the updated cur_output_stats after merge — care: merge happens after the loop over outputs, so for the same chunk we must use the stats that include the current delta; the code currently merges at the end of the for output loop, so the stats in the map are updated after we've already used cur_output_stats for callbacks. So we need to either:
       (1) Merge cur_output_stats into the map first, then get the merged stats from the map and call get_output_status(merged_stats, prev), and use that for OutputContext and completion callbacks, or
       (2) Compute cur_output_stats, merge into map, then re-read from map for get_output_status.
     - Recommendation: merge into output_stats first, then get merged = output_stats.get(&cur_output_index).unwrap(), then (reasoning_status, content_status) = get_output_status(merged, prev_output_stats). Use these for OutputContext and for the completion flags/callbacks.
     - Remove the two get_reasoning_status / get_content_status calls and the "AI TODO" / "AI TO DELETE" comments.

  C. Delete get_reasoning_status and get_content_status
     - Remove the two functions and their "AI TO DELETE" comments.
     - Ensure tests still pass: existing tests that assert on OutputContext or completion callbacks should still pass if semantics are preserved. Any unit tests that call get_reasoning_status / get_content_status directly need to be updated to use get_output_status with an OutputStats built from the same inputs (or removed if redundant).

  D. Tests
     - Add unit tests for get_output_status covering:
       - Init/Init: no tokens, not finished.
       - Pending/Init: reasoning tokens, no content, not finished.
       - Complete/Pending: no reasoning, content tokens, not finished.
       - Complete/Complete: finished (with or without tokens).
       - Tool-call-only output: 0/0 tokens, finish_reason ReasonToolCalls → Complete/Complete.
     - Run existing stream/process and assemble tests to confirm no regressions.

3.3 Order of implementation

  1. Implement get_output_status with the logic above; leave get_reasoning_status and get_content_status in place.
  2. Add unit tests for get_output_status (and optionally keep or adapt tests for the old helpers if they exist).
  3. In the process loop: merge cur_output_stats into output_stats, then retrieve merged stats, call get_output_status(merged, prev_output_stats), use the returned (reasoning_status, content_status) for OutputContext and for the completion callbacks; remove the calls to get_reasoning_status and get_content_status.
  4. Remove get_reasoning_status and get_content_status and any "AI TODO" / "AI TO DELETE" comments.
  5. Run full test suite and fix any failing tests or call sites.

================================================================================
4. SUMMARY
-----------------------------------------------------

- Chunks are GetChatCompletionChunk with one or more CompletionOutputChunk in outputs; each has index, delta, finish_reason. Deltas carry content and reasoning_content; token counts are accumulated in OutputStats per output index.
- Phase status (reasoning/content) should be derived from OutputStats (totals + finish_reason) via get_output_status, replacing the current delta-based get_reasoning_status and get_content_status, so that completion callbacks and OutputContext stay correct and the design is stats-based and extensible.
- Implementation: implement get_output_status, switch the loop to use merged stats and get_output_status, add tests, then remove the old helpers and comments.
