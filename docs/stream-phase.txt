================================================================================
Stream phase tracking: analysis and implementation plan
================================================================================

1. ANALYSIS OF debug/chunks.txt — HOW CHUNKS ARE STREAMED
---------------------------------------------------------

1.1 Top-level structure

  - The stream is a sequence of GetChatCompletionChunk values.
  - Each chunk has:
    - id, created, model, system_fingerprint, usage, citations, debug_output
    - outputs: [CompletionOutputChunk]  — typically ONE output per chunk in the trace

1.2 Per-chunk output (CompletionOutputChunk)

  - index: i32
    - Identifies which "output" this chunk belongs to. In the trace: 0, 1, 2, 3.
    - Outputs are ordered: all index 0 chunks, then index 1, then 2, then 3, etc.
  - delta: Option<Delta>
    - Present for every chunk that carries new content; can be Some(Delta { content: "", ... }) for tool/control chunks.
  - finish_reason: FinishReason
    - ReasonInvalid (0): streaming in progress, more data may follow for this output.
    - ReasonToolCalls (4): this output ended with tool calls (e.g. index 0 in the trace).
    - ReasonStop (3): this output ended normally (e.g. final content output, index 3).
  - logprobs: optional

1.3 Delta contents

  - content: str           — user-visible text (can be "" for reasoning/tool-only chunks).
  - reasoning_content: str — chain-of-thought / reasoning tokens (can be "" when no reasoning in this delta).
  - role: MessageRole      — RoleAssistant, RoleTool, etc.
  - tool_calls: [ToolCall] — server-side or client-side tool call deltas.
  - encrypted_content, citations

  Token semantics (for phase tracking):
  - A delta with non-empty reasoning_content contributes one (or more) reasoning tokens.
  - A delta with non-empty content contributes one (or more) content tokens.
  - The SDK currently counts one token per delta when the corresponding string is non-empty (see OutputStats::inc).

1.4 Observed stream shape (from debug/chunks.txt)

  - Index 0: Several chunks with tool_calls (XSearchTool, InProgress), then one chunk with finish_reason: ReasonToolCalls, empty tool_calls.
  - Index 1: One chunk, role RoleTool, tool_calls with status Completed (no content/reasoning).
  - Index 2: One chunk, same pattern (tool result).
  - Index 3: Many chunks; each has content like "###", " Last", " Two", " Tweets", ... and reasoning_content: "".
  - Last chunk for index 3: delta with content: "", reasoning_content: "", finish_reason: ReasonStop.
    - This is the "output finished" signal; usage and citations appear on this chunk.

  So:
  - One output per chunk in this trace; output index increases over time (0 → 1 → 2 → 3).
  - Reasoning phase: no reasoning tokens in this trace for index 3 (all reasoning_content empty).
  - Content phase: content tokens stream until the final chunk with ReasonStop and empty delta.

1.5 Chunk metadata

  - Chunks with created: Some(...) carry usage (completion_tokens, reasoning_tokens, etc.); "tool result" chunks (index 1, 2) have created: None and zero usage.
  - finish_reason is per output and is the authoritative "this output is done" signal when not ReasonInvalid.

================================================================================
2. FROM STREAM CHUNKS TO WHAT NEEDS TO BE IMPLEMENTED
-----------------------------------------------------

2.1 Current behavior (delta-based phase status)

  - For each chunk, for each output in chunk.outputs, the code:
    1. Updates OutputStats: total_reasoning_tokens, total_content_tokens, finish_reason (via merge).
    2. Computes reasoning_status and content_status using get_reasoning_status and get_content_status from the *current delta* and output.finish_reason.
    3. Uses these statuses to build OutputContext and to fire on_reasoning_complete / on_content_complete once (guarded by reasoning_complete_flags / content_complete_flags).

  - get_reasoning_status(reasoning_content, content, finish_reason):
    - has_reasoning = !reasoning_content.is_empty()
    - has_content  = !content.is_empty()
    - is_finished  = (finish_reason != ReasonInvalid)
    - Complete if !has_reasoning && (has_content || is_finished)
    - Pending if has_reasoning && !has_content
    - Init otherwise

  - get_content_status(reasoning_content, content, finish_reason):
    - Same has_* and is_finished
    - Complete if !has_reasoning && is_finished
    - Pending if has_content
    - Init otherwise

  So: phase status is derived from the *current* delta and the *current* finish_reason. It can change every chunk and is not yet driven by accumulated stats.

2.2 Intended behavior (stats-based phase status)

  - We already accumulate per-output:
    - total_reasoning_tokens, total_content_tokens (via OutputStats::inc and merge),
    - finish_reason (last one seen for that output, via merge).
  - Goal: compute the same logical PhaseStatus (Init / Pending / Complete) for reasoning and content from these accumulated stats instead of from the current delta.
  - Benefits:
    - Single source of truth (stats) for progress.
    - Status is stable and consistent with the full history of the output (no per-delta flicker).
    - Enables future extensions (e.g. progress percentages from token counts) without duplicating logic.

2.3 What must be implemented

  - Implement get_output_status(cur_output_stats, prev_output_stats) -> (PhaseStatus, PhaseStatus).
  - Replace the use of get_reasoning_status and get_content_status in the process loop with get_output_status.
  - Remove get_reasoning_status and get_content_status (or keep only for tests if needed).
  - New completion semantics (no parity with current behavior required):
    - on_reasoning_complete and on_content_complete fire only during a transition from one output to the next (i.e. when we start processing a chunk for output index N+1, we consider output N "done").
    - Fire on_reasoning_complete for the previous output only if that output had any reasoning tokens (total_reasoning_tokens > 0).
    - Fire on_content_complete for the previous output only if that output had any content tokens (total_content_tokens > 0).
    - When the stream ends (no more chunks), fire the same completes for the final output if it had reasoning/content (transition to "no next output").

================================================================================
3. IMPLEMENTATION PLAN
-----------------------------------------------------

3.1 Semantics of get_output_status (stats-based)

  Inputs:
  - cur_output_stats: &OutputStats
      - index, total_reasoning_tokens, total_content_tokens, finish_reason
  - prev_output_stats: Option<&OutputStats>
      - Used for completion callback firing (see 3.2): when we transition to the next output, we use the previous output's stats to decide whether to fire on_reasoning_complete / on_content_complete.

  get_output_status returns (reasoning_status, content_status) for the *current* output (for OutputContext only). Phase status rules:

  - is_finished = (cur_output_stats.finish_reason != FinishReason::ReasonInvalid)
  - Reasoning status:
    - Complete: is_finished, or (total_reasoning_tokens == 0 && total_content_tokens > 0)
    - Pending: total_reasoning_tokens > 0 && total_content_tokens == 0
    - Otherwise: Init
  - Content status:
    - Complete: is_finished
    - Pending: total_content_tokens > 0 && !is_finished
    - Otherwise: Init

  Completion callbacks (separate from get_output_status):
  - Do not fire when the current output's phase becomes Complete.
  - Fire only on *transition to the next output* (or end of stream for the final output):
    - When we first see a chunk for output index K where K > the previous output index we processed, we have "transitioned" from output K-1. Then: if output_stats for index K-1 has total_reasoning_tokens > 0, fire on_reasoning_complete for output K-1 (with OutputContext for K-1). If it has total_content_tokens > 0, fire on_content_complete for output K-1.
    - When the stream ends (chunk is None and we break), fire on_reasoning_complete / on_content_complete for the last output index we ever saw, if that output had reasoning/content respectively.
  - prev_output_stats (or output_stats.get(&(cur_output_index - 1))) is used when we detect a transition to decide whether the previous output had reasoning/content and thus whether to fire.

3.2 Code changes

  A. Implement get_output_status in sdk/src/chat.rs
     - Add helper or inline: is_finished = cur_output_stats.finish_reason != FinishReason::ReasonInvalid.into()
     - Reasoning: if total_reasoning_tokens == 0 && (total_content_tokens > 0 || is_finished) { Complete } else if total_reasoning_tokens > 0 && total_content_tokens == 0 { Pending } else { Init }
     - Content: if is_finished { Complete } else if total_content_tokens > 0 { Pending } else { Init }
     - Return (reasoning_status, content_status).

  B. Switch the process loop to stats-based status and transition-based completions
     - Merge cur_output_stats into output_stats first, then get merged stats for cur_output_index. Call get_output_status(merged, prev_output_stats) and use the result for OutputContext only (not for firing completions).
     - Transition-based completion firing:
       (1) When we are about to process an output with index K (K >= 0): if K >= 1, we have "transitioned past" output K-1. If we have not yet fired completions for K-1 (use reasoning_complete_flags / content_complete_flags keyed by output index), get output_stats for K-1; if total_reasoning_tokens > 0 call on_reasoning_complete for K-1; if total_content_tokens > 0 call on_content_complete for K-1; then set the flags for K-1 so we don't fire again.
       (2) When the stream ends (we break because chunk is None): for the highest output index we ever saw, if we haven't fired completions for that index, fire on_reasoning_complete / on_content_complete if that output had reasoning/content. Track the max output index seen (e.g. across the loop) so we know the final output at end of stream.
     - Remove the two get_reasoning_status / get_content_status calls and the "AI TODO" / "AI TO DELETE" comments.

  C. Delete get_reasoning_status and get_content_status
     - Remove the two functions and their "AI TO DELETE" comments.
     - Update tests: completion callback semantics change (transition-based, not phase-Complete-based). Tests that assert on when on_reasoning_complete / on_content_complete are called must expect them only at output transitions (or stream end), and only when the previous/final output had reasoning/content. Any unit tests that call get_reasoning_status / get_content_status directly should be updated to use get_output_status or removed.

  D. Tests
     - Add unit tests for get_output_status covering:
       - Init/Init: no tokens, not finished.
       - Pending/Init: reasoning tokens, no content, not finished.
       - Complete/Pending: no reasoning, content tokens, not finished.
       - Complete/Complete: finished (with or without tokens).
       - Tool-call-only output: 0/0 tokens, finish_reason ReasonToolCalls → Complete/Complete.
     - Add or update tests for completion callbacks: they fire only on transition to next output (or stream end), and only when the previous/final output had reasoning or content respectively.
     - Run existing stream/process and assemble tests; update expectations for completion callback timing.

3.3 Order of implementation

  1. Implement get_output_status with the logic above; leave get_reasoning_status and get_content_status in place.
  2. Add unit tests for get_output_status (and optionally keep or adapt tests for the old helpers if they exist).
  3. In the process loop: merge cur_output_stats into output_stats, then retrieve merged stats, call get_output_status(merged, prev_output_stats), use the returned (reasoning_status, content_status) for OutputContext and for the completion callbacks; remove the calls to get_reasoning_status and get_content_status.
  4. Remove get_reasoning_status and get_content_status and any "AI TODO" / "AI TO DELETE" comments.
  5. Run full test suite and fix any failing tests or call sites.

================================================================================
4. SUMMARY
-----------------------------------------------------

- Chunks are GetChatCompletionChunk with one or more CompletionOutputChunk in outputs; each has index, delta, finish_reason. Deltas carry content and reasoning_content; token counts are accumulated in OutputStats per output index.
- Phase status (reasoning/content) for OutputContext is derived from OutputStats via get_output_status. Completion callbacks do not fire when the current output's phase becomes Complete; they fire only on transition to the next output (or at stream end for the final output), and only if that output had reasoning or content respectively.
- Implementation: implement get_output_status; switch the loop to use merged stats and get_output_status for OutputContext; add transition detection and fire on_reasoning_complete / on_content_complete only at output boundaries when the previous/final output had tokens; add tests and update existing completion-callback expectations; remove get_reasoning_status and get_content_status.
