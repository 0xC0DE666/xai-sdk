// This file is @generated by prost-build.
/// Allows the user to specify a time range in their local timezone.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeRange {
    /// The from-time in the format YYYY-MM-DD HH:MM:SS.
    #[prost(string, tag = "1")]
    pub start_time: ::prost::alloc::string::String,
    /// The to-time in the format YYYY-MM-DD HH:MM:SS (not including).
    #[prost(string, tag = "2")]
    pub end_time: ::prost::alloc::string::String,
    /// The timezone that all timestamps are reported in.
    /// The timezone must be represented by the IANA time zone identifier (e.g. America/New_York).
    #[prost(string, tag = "3")]
    pub timezone: ::prost::alloc::string::String,
}
/// Determines which values shall be measured and how they shall be aggregated.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Value {
    /// Name of the field to measure.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Aggregation method to use.
    #[prost(enumeration = "Aggregation", tag = "2")]
    pub aggregation: i32,
}
/// Request body for analytics.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyticsRequest {
    /// The range over which to return the time series.
    #[prost(message, optional, tag = "1")]
    pub time_range: ::core::option::Option<TimeRange>,
    /// The granularity of the returned aggregation.
    #[prost(enumeration = "TimeUnit", tag = "2")]
    pub time_unit: i32,
    /// Name of the fields to aggregate.
    #[prost(message, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<Value>,
    /// For each value of the group-by tuple, we return one time series.
    #[prost(string, repeated, tag = "4")]
    pub group_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A conditions that filter the individual log items, which get analyzed.
    /// Syntax:
    /// (NOT) \[field\]:\[operator\]\[value\] (AND|OR)
    /// Example:
    /// api_key_id:0000-9999-9999-9999
    /// usage:>100
    ///
    /// All filter conditions are combined using AND.
    #[prost(string, repeated, tag = "5")]
    pub filters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response body for analytics.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyticsResponse {
    /// For each value of the group-by clause, we return one time series.
    #[prost(message, repeated, tag = "1")]
    pub time_series: ::prost::alloc::vec::Vec<TimeSeries>,
    /// If this is true, the maximum cardinality of the query has been reached and only a subset of
    /// results is returned.
    #[prost(bool, tag = "2")]
    pub limit_reached: bool,
}
/// A time series is a sequence of values.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
    /// Values of the fields that were grouped by.
    #[prost(string, repeated, tag = "1")]
    pub group: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Values to group the time series by.
    #[prost(string, repeated, tag = "3")]
    pub group_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Data points ordered by timestamp. Data points are dense in the range provided (meaning we
    /// return one data point for every interval in the requested time range).
    #[prost(message, repeated, tag = "2")]
    pub data_points: ::prost::alloc::vec::Vec<DataPoint>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataPoint {
    /// The timestamp (in UTC) when the data point was recorded.
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_wkt_types::Timestamp>,
    /// The values that were recorded at that datapoint.
    #[prost(double, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<f64>,
}
/// The analytics scheme specifies which fields can be measured, group by, and filtered by.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyticsScheme {
    /// List of values that can be measured.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<ValueScheme>,
    /// List of fields that can be filtered by.
    #[prost(string, repeated, tag = "2")]
    pub filters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of fields that can be grouped by.
    #[prost(string, repeated, tag = "3")]
    pub group_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Specifies a value and which aggregation methods it supports.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValueScheme {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "Aggregation", repeated, tag = "2")]
    pub aggregations: ::prost::alloc::vec::Vec<i32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringRawValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatRawValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub value: f64,
}
/// Generic representation of a Clickhouse row.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyticsRow {
    /// Unique identifier for this log item. May or may not
    /// represent anything else in the system.
    #[prost(string, tag = "1")]
    pub log_id: ::prost::alloc::string::String,
    /// Values for numerical columns in the log.
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<FloatRawValue>,
    /// String values coming from the group-by fields.
    #[prost(message, repeated, tag = "3")]
    pub group_by_values: ::prost::alloc::vec::Vec<StringRawValue>,
    /// String values coming from the filter-by fields.
    /// This is NOT deduplicated from `group_by_values`
    /// in case a column can be a filter and a group-by.
    #[prost(message, repeated, tag = "4")]
    pub filter_by_values: ::prost::alloc::vec::Vec<StringRawValue>,
    /// The UTC timestamp when the data was recorded.
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
/// Time series are created by aggregating value into buckets we call `TimeUnit`.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeUnit {
    Invalid = 0,
    Month = 1,
    CalendarWeek = 2,
    Day = 3,
    Hour = 4,
    QuarterHour = 5,
    Minute = 6,
    Second = 7,
    /// None means having one single time bucket for all events.
    /// This can be used to count total number of events ever for example.
    None = 8,
}
impl TimeUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "TIME_UNIT_INVALID",
            Self::Month => "TIME_UNIT_MONTH",
            Self::CalendarWeek => "TIME_UNIT_CALENDAR_WEEK",
            Self::Day => "TIME_UNIT_DAY",
            Self::Hour => "TIME_UNIT_HOUR",
            Self::QuarterHour => "TIME_UNIT_QUARTER_HOUR",
            Self::Minute => "TIME_UNIT_MINUTE",
            Self::Second => "TIME_UNIT_SECOND",
            Self::None => "TIME_UNIT_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIME_UNIT_INVALID" => Some(Self::Invalid),
            "TIME_UNIT_MONTH" => Some(Self::Month),
            "TIME_UNIT_CALENDAR_WEEK" => Some(Self::CalendarWeek),
            "TIME_UNIT_DAY" => Some(Self::Day),
            "TIME_UNIT_HOUR" => Some(Self::Hour),
            "TIME_UNIT_QUARTER_HOUR" => Some(Self::QuarterHour),
            "TIME_UNIT_MINUTE" => Some(Self::Minute),
            "TIME_UNIT_SECOND" => Some(Self::Second),
            "TIME_UNIT_NONE" => Some(Self::None),
            _ => None,
        }
    }
}
/// Each value is an aggregate of the individual values in the time bucket. Note that not every field
/// supports every aggregation method.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Aggregation {
    None = 0,
    Sum = 1,
    Avg = 2,
    Var = 3,
    Std = 4,
    Min = 5,
    Max = 6,
    P50 = 7,
    P90 = 8,
    P99 = 9,
    P999 = 10,
    Count = 11,
    CountDistinct = 12,
}
impl Aggregation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "AGGREGATION_NONE",
            Self::Sum => "AGGREGATION_SUM",
            Self::Avg => "AGGREGATION_AVG",
            Self::Var => "AGGREGATION_VAR",
            Self::Std => "AGGREGATION_STD",
            Self::Min => "AGGREGATION_MIN",
            Self::Max => "AGGREGATION_MAX",
            Self::P50 => "AGGREGATION_P50",
            Self::P90 => "AGGREGATION_P90",
            Self::P99 => "AGGREGATION_P99",
            Self::P999 => "AGGREGATION_P999",
            Self::Count => "AGGREGATION_COUNT",
            Self::CountDistinct => "AGGREGATION_COUNT_DISTINCT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGGREGATION_NONE" => Some(Self::None),
            "AGGREGATION_SUM" => Some(Self::Sum),
            "AGGREGATION_AVG" => Some(Self::Avg),
            "AGGREGATION_VAR" => Some(Self::Var),
            "AGGREGATION_STD" => Some(Self::Std),
            "AGGREGATION_MIN" => Some(Self::Min),
            "AGGREGATION_MAX" => Some(Self::Max),
            "AGGREGATION_P50" => Some(Self::P50),
            "AGGREGATION_P90" => Some(Self::P90),
            "AGGREGATION_P99" => Some(Self::P99),
            "AGGREGATION_P999" => Some(Self::P999),
            "AGGREGATION_COUNT" => Some(Self::Count),
            "AGGREGATION_COUNT_DISTINCT" => Some(Self::CountDistinct),
            _ => None,
        }
    }
}
